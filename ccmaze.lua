-- This file was auto-generated on 2025-05-31 01:13:19
local files = {} local globalRequire = require local require = function(path) return files[path]() or globalRequire(path) end local ccmaze = {require = require}files['ccmaze.maze'] = function(...)  local maze = {}   local optFunc = require("ccmaze.utils.optFunc")  local Maze = { width = 0, height = 0, cells = {} }  function Maze:update_grid(producer, onUpdates) repeat local status, updates = coroutine.resume(producer) if updates ~= nil and status then for i = 1, #updates, 1 do local u = updates[i] self.cells[(u.i - 1) * self.width + u.j] = u.state end optFunc.create1(onUpdates)(updates) end until not status end  function Maze:new(width, height, producer, onUpdates) local m = { width = width, height = height, cells = {} } setmetatable(m, self) self.__index = self for i = 1, width*height, 1 do m.cells[i] = 0 end m:update_grid(producer, optFunc.create1(onUpdates)) return m end   function maze.new(width, height, producer, onUpdates) return Maze:new(width, height, producer, optFunc.create1(onUpdates)) end  return maze  end files['ccmaze.stateUpdate'] = function(...) local stateUpdate = {}   local StateUpdate = { i = 0, j = 0, state = 0, progress = 0 }  function StateUpdate:new(i, j, state, progress) local s = { i = i, j = j, state = state, progress = progress } setmetatable(s, self) self.__index = self return s end   function stateUpdate.new(i, j, state, progress) return StateUpdate:new(i, j, state, progress) end  return stateUpdate  end files['ccmaze.filters.builder'] = function(...) local builder = {}   function builder.build(producer, f, args) return coroutine.create(function() repeat local status, updates = coroutine.resume(producer) if updates ~= nil and status then updates = f(updates, unpack(args or {})) coroutine.yield(updates) end until not status end) end  return builder  end files['ccmaze.filters.computerCraft'] = function(...) local computerCraft = {}   local builder = require("ccmaze.filters.builder")  local function _updateScreen(updates, monitor, color_table) for i = 1, #updates, 1 do local u = updates[i] monitor.setBackgroundColor(color_table[u.state]) monitor.setCursorPos(u.j, u.i) monitor.write(" ") end return updates end  local function _displayText(monitor, x, y, txt, maxSize) monitor.setBackgroundColor(colors.black) monitor.setTextColor(colors.white) monitor.setCursorPos(x, y) monitor.write(string.rep(" ", maxSize)) monitor.setCursorPos(x, y) monitor.write(txt) end  local function _displayProgress(updates, monitor, x, y, prefix, maxPrefixSize) local maxProgress = 0 for i = 1, #updates, 1 do local u = updates[i] maxProgress = math.max(maxProgress, u.progress) end local txt = prefix .. string.format("%.2f", maxProgress * 100) .. "%" _displayText(monitor, x, y, txt, maxPrefixSize + 7) return updates end    function computerCraft.updateScreen(producer, monitor, color_table) return builder.build(producer, _updateScreen, { monitor, color_table }) end  function computerCraft.displayProgress(producer, monitor, x, y, prefix, maxPrefixSize) return builder.build(producer, _displayProgress, { monitor, x, y, prefix, maxPrefixSize }) end  return computerCraft  end files['ccmaze.generators.abstract'] = function(...) local abstractGenerator = {}   local Generator = { width = 0, height = 0, cellStates = {} }  function Generator:new(width, height) Generator.__index = Generator local obj = { width = width, height = height, cellStates = {} } setmetatable(obj, Generator) return obj end  function Generator:producer() return coroutine.create(function() self:_init() self:generate() end) end  function Generator:generate() error("Abstract method Generator:generate called", 1) end  function Generator:_init() error("Abstract method Generator:_init called", 1) end  function Generator:_progression() error("Abstract method Generator:_progression called", 1) end   function abstractGenerator.new(width, height) return Generator:new(width, height) end  return abstractGenerator  end files['ccmaze.generators.deepFirst'] = function(...) local deepFirstGenerator = {}   local stateUpdate = require("ccmaze.stateUpdate") local abstractGenerator = require("ccmaze.generators.abstract") local stack = require("ccmaze.utils.stack")  local CELL_STATES = { VISITED = 1, WALL = 2, UNVISITED = 3, SELECTED = 4 }  local DFSGenerator = { _internalWidth = 0, _internalHeight = 0, _cells = {}, _path = {}, _count = 0, _startCoords = {} }  function DFSGenerator:_progression() return 1.0 - self._count / (self._internalWidth * self._internalHeight - 1) end  function DFSGenerator:_init() self._internalWidth = math.floor((self.width - 1) / 2) self._internalHeight = math.floor((self.height - 1) / 2) self._count = self._internalWidth * self._internalHeight - 1 self._path = stack.new() for i = 1, self._internalHeight, 1 do for j = 1, self._internalWidth, 1 do self:_setState({ i = i, j = j }, CELL_STATES.UNVISITED) end end self._startCoords = { i = math.random(self._internalHeight), j = math.random(self._internalWidth) } self:_setState(self._startCoords, CELL_STATES.VISITED) self._path:push(self._startCoords) end  function DFSGenerator:new(width, height) local obj = abstractGenerator.new(width, height) DFSGenerator.__index = DFSGenerator setmetatable(DFSGenerator, { __index = getmetatable(obj) }) setmetatable(obj, DFSGenerator) obj.cellStates = CELL_STATES return obj end  function DFSGenerator:_updateWall(coords1, coords2, state) return stateUpdate.new(coords1.i + coords2.i, coords1.j + coords2.j, state, self:_progression()) end  function DFSGenerator:_updateCell(coords, state) return stateUpdate.new(coords.i * 2, coords.j * 2, state, self:_progression()) end  function DFSGenerator:_getState(coords) return self._cells[(coords.i - 1) * self._internalWidth + coords.j] end  function DFSGenerator:_setState(coords, state) self._cells[(coords.i - 1) * self._internalWidth + coords.j] = state end  function DFSGenerator:_isUnvisited(coords) return self:_getState(coords) == CELL_STATES.UNVISITED end  function DFSGenerator:_getRandomNeighbor(coords) local top = { i = coords.i - 1, j = coords.j } local bottom = { i = coords.i + 1, j = coords.j } local left = { i = coords.i, j = coords.j - 1 } local right = { i = coords.i, j = coords.j + 1 }  local neighbors = {}  if coords.i > 1 and self:_isUnvisited(top) then table.insert(neighbors, top) end if coords.i < self._internalHeight and self:_isUnvisited(bottom) then table.insert(neighbors, bottom) end if coords.j > 1 and self:_isUnvisited(left) then table.insert(neighbors, left) end if coords.j < self._internalWidth and self:_isUnvisited(right) then table.insert(neighbors, right) end  if #neighbors == 0 then return nil else return neighbors[math.random(#neighbors)] end end  function DFSGenerator:generate() local updates = {} for i = 1, self.height, 1 do for j = 1, self.width, 1 do if (i % 2 == 0) and (j % 2 == 0) and i < self.height and j < self.width then table.insert(updates, stateUpdate.new(i, j, CELL_STATES.UNVISITED, 0)) else table.insert(updates, stateUpdate.new(i, j, CELL_STATES.WALL, 0)) end end end table.insert(updates, self:_updateCell(self._path:peek(), CELL_STATES.SELECTED)) coroutine.yield(updates)  while self._count > 0 do local coords = self._path:pop()  if self:_isUnvisited(coords) then self._count = self._count - 1 self:_setState(coords, CELL_STATES.VISITED) end  local nextCoords = self:_getRandomNeighbor(coords) if nextCoords ~= nil then self._path:push(coords) self._path:push(nextCoords) coroutine.yield({ self:_updateWall(coords, nextCoords, CELL_STATES.VISITED), self:_updateCell(coords, CELL_STATES.VISITED), self:_updateCell(nextCoords, CELL_STATES.SELECTED), }) else coroutine.yield({ self:_updateCell(coords, CELL_STATES.VISITED), self:_updateCell(self._path:peekOr(self._startCoords), CELL_STATES.SELECTED), }) end end coroutine.yield({ self:_updateCell(self._path:popOr(self._startCoords), CELL_STATES.VISITED) }) end   function deepFirstGenerator.new(width, height) return DFSGenerator:new(width, height) end  return deepFirstGenerator  end files['ccmaze.generators.kruskal'] = function(...) local kruskalGenerator = {}   local stateUpdate = require("ccmaze.stateUpdate") local abstractGenerator = require("ccmaze.generators.abstract") local dSet = require("ccmaze.utils.dSet") local stack = require("ccmaze.utils.stack")   local DIRECTIONS = { VERTICAL = 0, HORIZONTAL = 1 }  local Wall = { i = 0, j = 0, direction = DIRECTIONS.VERTICAL }  function Wall.new(i, j, direction) return { i = i, j = j, direction = direction } end  local CELL_STATES = { VISITED = 1, WALL = 2, UNVISITED = 3, SELECTED = 4 }   local KruskalGenerator = { _internalWidth = 0, _internalHeight = 0, _sets = {}, _walls = {}, _count = 0, }  function KruskalGenerator:_progression() return 1.0 - self._count / (self._internalWidth * self._internalHeight - 1) end  function KruskalGenerator:_init() self._internalWidth = math.floor((self.width - 1) / 2) self._internalHeight = math.floor((self.height - 1) / 2) self._count = self._internalWidth * self._internalHeight - 1 self._walls = stack.new() self._sets = {} for i = 1, self._internalHeight, 1 do for j = 1, self._internalWidth, 1 do self._sets[(i - 1) * self._internalWidth + j] = dSet.makeSet({ i = i, j = j }) if i > 1 then self._walls:push(Wall.new(i, j, DIRECTIONS.VERTICAL)) end if j > 1 then self._walls:push(Wall.new(i, j, DIRECTIONS.HORIZONTAL)) end end end self._walls:shuffle() end  function KruskalGenerator:new(width, height) local obj = abstractGenerator.new(width, height) KruskalGenerator.__index = KruskalGenerator setmetatable(KruskalGenerator, { __index = getmetatable(obj) }) setmetatable(obj, KruskalGenerator) obj.cellStates = CELL_STATES return obj end  function KruskalGenerator:_getSets(wall) if wall.direction == DIRECTIONS.VERTICAL then return self._sets[(wall.i - 2) * self._internalWidth + wall.j], self._sets [(wall.i - 1) * self._internalWidth + wall.j] else return self._sets[(wall.i - 1) * self._internalWidth + wall.j - 1], self._sets[(wall.i - 1) * self._internalWidth + wall.j] end end  function KruskalGenerator:_updateFromWall(wall, state) local ci = wall.i * 2 local cj = wall.j * 2 if wall.direction == DIRECTIONS.VERTICAL then ci = ci - 1 end if wall.direction == DIRECTIONS.HORIZONTAL then cj = cj - 1 end return stateUpdate.new(ci, cj, state, self:_progression()) end  function KruskalGenerator:_updateFromSet(set, state) local ci = set.data.i * 2 local cj = set.data.j * 2 return stateUpdate.new(ci, cj, state, self:_progression()) end  function KruskalGenerator:generate() local updates = {} for i = 1, self.height, 1 do for j = 1, self.width, 1 do if (i % 2 == 0) and (j % 2 == 0) and i < self.height and j < self.width  then table.insert(updates, stateUpdate.new(i, j, CELL_STATES.UNVISITED, 0)) else table.insert(updates, stateUpdate.new(i, j, CELL_STATES.WALL, 0)) end end end coroutine.yield({ self:_updateFromWall(self._walls:peek(), CELL_STATES.SELECTED) }) coroutine.yield(updates)  local startCoord = { i = 0, j = 0 } while self._count > 0 do local wall = self._walls:pop()  local sa, sb = self:_getSets(wall)  if sa:connected(sb) then local updates = { self:_updateFromWall(wall, CELL_STATES.WALL) } if not self._walls:isEmpty() then table.insert(updates, self:_updateFromWall(self._walls:peek(), CELL_STATES.SELECTED)) end coroutine.yield(updates) else self._count = self._count - 1 local updates = { self:_updateFromWall(wall, CELL_STATES.VISITED), self:_updateFromSet(sa, CELL_STATES.VISITED), self:_updateFromSet(sb, CELL_STATES.VISITED) } if not self._walls:isEmpty() then table.insert(updates, self:_updateFromWall(self._walls:peek(), CELL_STATES.SELECTED)) end coroutine.yield(updates) sa:union(sb) end end if not self._walls:isEmpty() then coroutine.yield({ self:_updateFromWall(self._walls:peek(), CELL_STATES.WALL) }) end end   function kruskalGenerator.new(width, height) return KruskalGenerator:new(width, height) end  return kruskalGenerator  end files['ccmaze.generators.originShift'] = function(...) local originShiftGenerator = {}   local stateUpdate = require("ccmaze.stateUpdate") local abstractGenerator = require("ccmaze.generators.abstract")  local Node = { parent = {}, coords = { i = 0, j = 0 } }  function Node.new(i, j) return { parent = nil, coords = { i = i, j = j } } end  local CELL_STATES = { VISITED = 1, WALL = 2, SELECTED = 3 }  local OSGenerator = { _internalWidth = 0, _internalHeight = 0, _nodes = {}, _count = 0, _nbSteps = 0, _root = {} }  function OSGenerator:_progression() return 1.0 - self._count / self._nbSteps end  function OSGenerator:_init() self._internalWidth = math.floor((self.width - 1) / 2) self._internalHeight = math.floor((self.height - 1) / 2) self._count = self._nbSteps for i = 1, self._internalHeight, 1 do for j = 1, self._internalWidth, 1 do self._nodes[(i - 1) * self._internalWidth + j] = Node.new(i, j) end end  for i = 1, self._internalHeight, 1 do for j = 1, self._internalWidth - 1, 1 do self._nodes[(i - 1) * self._internalWidth + j].parent = self._nodes[(i - 1) * self._internalWidth + j + 1] end if i < self._internalHeight then self._nodes[i * self._internalWidth].parent = self._nodes[(i + 1) * self._internalWidth] end end  self._root = self:_getNode({ i = self._internalHeight, j = self._internalWidth }) end  function OSGenerator:new(width, height, nbSteps) local obj = abstractGenerator.new(width, height) OSGenerator.__index = OSGenerator setmetatable(OSGenerator, { __index = getmetatable(obj) }) setmetatable(obj, OSGenerator) obj.cellStates = CELL_STATES obj._nbSteps = nbSteps return obj end  function OSGenerator:_updateWall(coords1, coords2, state) return stateUpdate.new(coords1.i + coords2.i, coords1.j + coords2.j, state, self:_progression()) end  function OSGenerator:_updateCell(coords, state) return stateUpdate.new(coords.i * 2, coords.j * 2, state, self:_progression()) end  function OSGenerator:_getNode(coords) return self._nodes[(coords.i - 1) * self._internalWidth + coords.j] end  function OSGenerator:_getRandomNeighbor(coords) local top = { i = coords.i - 1, j = coords.j } local bottom = { i = coords.i + 1, j = coords.j } local left = { i = coords.i, j = coords.j - 1 } local right = { i = coords.i, j = coords.j + 1 }  local neighbors = {}  if coords.i > 1 then table.insert(neighbors, top) end if coords.i < self._internalHeight then table.insert(neighbors, bottom) end if coords.j > 1 then table.insert(neighbors, left) end if coords.j < self._internalWidth then table.insert(neighbors, right) end  return neighbors[math.random(#neighbors)] end  function OSGenerator:generate() local updates = {} for i = 1, self.height, 1 do for j = 1, self.width, 1 do local rowsCond = (i % 2 == 0 and j > 1 and j < self.width and i < self.height) local lastColCond = (i > 1 and i < self.height and j == self.width - 1) if rowsCond or lastColCond then table.insert(updates, stateUpdate.new(i, j, CELL_STATES.VISITED, 0)) else table.insert(updates, stateUpdate.new(i, j, CELL_STATES.WALL, 0)) end end end table.insert(updates, self:_updateCell(self._root.coords, CELL_STATES.SELECTED)) coroutine.yield(updates)  while self._count > 0 do local nextRootCoords = self:_getRandomNeighbor(self._root.coords) local nextRoot = self:_getNode(nextRootCoords)  coroutine.yield({ self:_updateWall(nextRootCoords, nextRoot.parent.coords, CELL_STATES.WALL), self:_updateWall(self._root.coords, nextRootCoords, CELL_STATES.VISITED), self:_updateCell(self._root.coords, CELL_STATES.VISITED), self:_updateCell(nextRootCoords, CELL_STATES.SELECTED), })  nextRoot.parent = nil self._root.parent = nextRoot self._root = nextRoot  self._count = self._count - 1 end coroutine.yield({ self:_updateCell(self._root.coords, CELL_STATES.VISITED) }) end   function originShiftGenerator.new(width, height, nbSteps) return OSGenerator:new(width, height, nbSteps) end  return originShiftGenerator  end files['ccmaze.postprocess.builder'] = function(...) local builder = {}   local optFunc = require("ccmaze.utils.optFunc")   function builder.build(f, args, onUpdates) return function(updates) optFunc.create1(onUpdates)(f(updates, unpack(args))) end end  return builder  end files['ccmaze.postprocess.computerCraft'] = function(...) local computerCraft = {}   local builder = require("ccmaze.postprocess.builder")  local function _wait(updates, time) sleep(time) return updates end  local function _updateScreen(updates, monitor, color_table) for i = 1, #updates, 1 do local u = updates[i] monitor.setBackgroundColor(color_table[u.state]) monitor.setCursorPos(u.j, u.i) monitor.write(" ") end return updates end   function computerCraft.wait(time, onUpdates) return builder.build(_wait, { time }, onUpdates) end  function computerCraft.updateScreen(monitor, color_table, onUpdates) return builder.build(_updateScreen, { monitor, color_table }, onUpdates) end  return computerCraft  end files['ccmaze.utils.dSet'] = function(...) local dSet = {}   local DSet = { data = nil, _parent = {}, _rang = 0 }  function DSet:new(o) o = o or { data = nil, _parent = nil, _rang = 0 } o._parent = o setmetatable(o, self) self.__index = self return o end  function DSet:makeSet(data) return DSet:new { data = data, _parent = nil, _rang = 0 } end  function DSet:union(other) local root = self:find() local other_root = other:find() if root ~= other_root then if root._rang < other._rang then root._parent = other_root else other_root._parent = root if root._rang == other_root._rang then root._rang = root._rang + 1 end end end end  function DSet:find() if self._parent ~= self then self._parent = self._parent:find() end return self._parent end  function DSet:connected(other) return self:find() == other:find() end   function dSet.new() return DSet:new() end  function dSet.makeSet(data) return DSet:makeSet(data) end  return dSet  end files['ccmaze.utils.optFunc'] = function(...) local optFunc = {}   function optFunc.create1(f) return (f or function(_) end) end  return optFunc  end files['ccmaze.utils.shuffle'] = function(...) local shuffle = {}   local function _shuffleInPlace(t) for i = #t, 2, -1 do local j = math.random(i) t[i], t[j] = t[j], t[i] end end   function shuffle.inPlace(t) _shuffleInPlace(t) end  return shuffle  end files['ccmaze.utils.stack'] = function(...)  local stack = {}   local shuffle = require "ccmaze.utils.shuffle"  local Stack = { _data = {} }  function Stack:new(o) o = o or { _data = {} } setmetatable(o, self) self.__index = self return o end  function Stack:makeStack(t) return Stack:new { _data = t } end  function Stack:isEmpty() return #self._data == 0 end  function Stack:size() return #self._data end  function Stack:push(elem) table.insert(self._data, elem) end  function Stack:pop() return table.remove(self._data) end  function Stack:popOr(default) if #self._data > 0 then return table.remove(self._data) else return default end end  function Stack:peek() return self._data[#self._data] end  function Stack:peekOr(default) if #self._data > 0 then return self._data[#self._data] else return default end end  function Stack:shuffle() shuffle.inPlace(self._data) end   function stack.new() return Stack:new() end  function stack.makeStack(t) return Stack:makeStack(t) end  return stack  end return ccmaze