local a={}local b=require;local require=function(c)return a[c]()or b(c)end;local d={require=require}a['ccmaze.maze']=function(...)local e={}local f=require("ccmaze.utils.optFunc")local g={width=0,height=0,cells={}}function g:rebuild(h,i)repeat local j,k=coroutine.resume(h)if k~=nil and j then for l=1,#k,1 do local m=k[l]self.cells[(m.i-1)*self.width+m.j]=m.state end;f.create1(i)(k)end until not j end;function g:new(n,o,h,i)local p={width=n,height=o,cells={}}setmetatable(p,self)self.__index=self;for l=1,n*o,1 do p.cells[l]=0 end;p:rebuild(h,f.create1(i))return p end;function e.new(n,o,h,i)return g:new(n,o,h,f.create1(i))end;return e end;a['ccmaze.stateUpdate']=function(...)local q={}local r={i=0,j=0,state=0,progress=0}function r:new(l,s,t,u)local v={i=l,j=s,state=t,progress=u}setmetatable(v,self)self.__index=self;return v end;function q.new(l,s,t,u)return r:new(l,s,t,u)end;return q end;a['ccmaze.filters.builder']=function(...)local w={}function w.build(h,x,y)return coroutine.create(function()repeat local j,k=coroutine.resume(h)if k~=nil and j then k=x(k,unpack(y or{}))coroutine.yield(k)end until not j end)end;return w end;a['ccmaze.filters.computerCraft']=function(...)local z={}local w=require("ccmaze.filters.builder")local function A(k,B,C)for l=1,#k,1 do local m=k[l]B.setBackgroundColor(C(m.state))B.setCursorPos(m.j,m.i)B.write(" ")end;return k end;local function D(B,E,F,G,H)B.setBackgroundColor(colors.black)B.setTextColor(colors.white)B.setCursorPos(E,F)B.write(string.rep(" ",H))B.setCursorPos(E,F)B.write(G)end;local function I(k,B,E,F,J,K)local L=0;for l=1,#k,1 do local m=k[l]L=math.max(L,m.progress)end;local G=J..string.format("%.2f",L*100).."%"D(B,E,F,G,K+7)return k end;function z.updateScreen(h,B,C)return w.build(h,A,{B,C})end;function z.displayProgress(h,B,E,F,J,K)return w.build(h,I,{B,E,F,J,K})end;return z end;a['ccmaze.generators.abstract']=function(...)local M={CELL_STATES={}}local N={width=0,height=0}function N:new(n,o)N.__index=N;local O={width=n,height=o}setmetatable(O,N)return O end;function N:producer()return coroutine.create(function()self:_init()self:generate()end)end;function N:generate()error("Abstract method Generator:generate called",1)end;function N:_init()error("Abstract method Generator:_init called",1)end;function N:_progression()error("Abstract method Generator:_progression called",1)end;function M.new(n,o)return N:new(n,o)end;return M end;a['ccmaze.generators.deepFirst']=function(...)local P={CELL_STATES={VISITED=1,WALL=2,UNVISITED=3,SELECTED=4}}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local Q=require("ccmaze.utils.stack")local R={_internalWidth=0,_internalHeight=0,_cells={},_path={},_count=0,_startCoords={}}function R:_progression()return 1.0-self._count/(self._internalWidth*self._internalHeight-1)end;function R:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._internalWidth*self._internalHeight-1;self._path=Q.new()for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self:_setState({i=l,j=s},P.CELL_STATES.UNVISITED)end end;self._startCoords={i=math.random(self._internalHeight),j=math.random(self._internalWidth)}self:_setState(self._startCoords,P.CELL_STATES.VISITED)self._path:push(self._startCoords)end;function R:new(n,o)local O=M.new(n,o)R.__index=R;setmetatable(R,{__index=getmetatable(O)})setmetatable(O,R)return O end;function R:_updateWall(S,T,t)return q.new(S.i+T.i,S.j+T.j,t,self:_progression())end;function R:_updateCell(U,t)return q.new(U.i*2,U.j*2,t,self:_progression())end;function R:_getState(U)return self._cells[(U.i-1)*self._internalWidth+U.j]end;function R:_setState(U,t)self._cells[(U.i-1)*self._internalWidth+U.j]=t end;function R:_isUnvisited(U)return self:_getState(U)==P.CELL_STATES.UNVISITED end;function R:_getRandomNeighbor(U)local V={i=U.i-1,j=U.j}local W={i=U.i+1,j=U.j}local X={i=U.i,j=U.j-1}local Y={i=U.i,j=U.j+1}local Z={}if U.i>1 and self:_isUnvisited(V)then table.insert(Z,V)end;if U.i<self._internalHeight and self:_isUnvisited(W)then table.insert(Z,W)end;if U.j>1 and self:_isUnvisited(X)then table.insert(Z,X)end;if U.j<self._internalWidth and self:_isUnvisited(Y)then table.insert(Z,Y)end;if#Z==0 then return nil else return Z[math.random(#Z)]end end;function R:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do if l%2==0 and s%2==0 and l<self.height and s<self.width then table.insert(k,q.new(l,s,P.CELL_STATES.UNVISITED,0))else table.insert(k,q.new(l,s,P.CELL_STATES.WALL,0))end end end;table.insert(k,self:_updateCell(self._path:peek(),P.CELL_STATES.SELECTED))coroutine.yield(k)while self._count>0 do local U=self._path:pop()if self:_isUnvisited(U)then self._count=self._count-1;self:_setState(U,P.CELL_STATES.VISITED)end;local _=self:_getRandomNeighbor(U)if _~=nil then self._path:push(U)self._path:push(_)coroutine.yield({self:_updateWall(U,_,P.CELL_STATES.VISITED),self:_updateCell(U,P.CELL_STATES.VISITED),self:_updateCell(_,P.CELL_STATES.SELECTED)})else coroutine.yield({self:_updateCell(U,P.CELL_STATES.VISITED),self:_updateCell(self._path:peekOr(self._startCoords),P.CELL_STATES.SELECTED)})end end;coroutine.yield({self:_updateCell(self._path:popOr(self._startCoords),P.CELL_STATES.VISITED)})end;function P.new(n,o)return R:new(n,o)end;return P end;a['ccmaze.generators.kruskal']=function(...)local a0={CELL_STATES={VISITED=1,WALL=2,UNVISITED=3,SELECTED=4}}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local a1=require("ccmaze.utils.dSet")local Q=require("ccmaze.utils.stack")local a2={VERTICAL=0,HORIZONTAL=1}local a3={i=0,j=0,direction=a2.VERTICAL}function a3.new(l,s,a4)return{i=l,j=s,direction=a4}end;local a5={_internalWidth=0,_internalHeight=0,_sets={},_walls={},_count=0}function a5:_progression()return 1.0-self._count/(self._internalWidth*self._internalHeight-1)end;function a5:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._internalWidth*self._internalHeight-1;self._walls=Q.new()self._sets={}for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self._sets[(l-1)*self._internalWidth+s]=a1.makeSet({i=l,j=s})if l>1 then self._walls:push(a3.new(l,s,a2.VERTICAL))end;if s>1 then self._walls:push(a3.new(l,s,a2.HORIZONTAL))end end end;self._walls:shuffle()end;function a5:new(n,o)local O=M.new(n,o)a5.__index=a5;setmetatable(a5,{__index=getmetatable(O)})setmetatable(O,a5)return O end;function a5:_getSets(a6)if a6.direction==a2.VERTICAL then return self._sets[(a6.i-2)*self._internalWidth+a6.j],self._sets[(a6.i-1)*self._internalWidth+a6.j]else return self._sets[(a6.i-1)*self._internalWidth+a6.j-1],self._sets[(a6.i-1)*self._internalWidth+a6.j]end end;function a5:_updateFromWall(a6,t)local a7=a6.i*2;local a8=a6.j*2;if a6.direction==a2.VERTICAL then a7=a7-1 end;if a6.direction==a2.HORIZONTAL then a8=a8-1 end;return q.new(a7,a8,t,self:_progression())end;function a5:_updateFromSet(a9,t)local a7=a9.data.i*2;local a8=a9.data.j*2;return q.new(a7,a8,t,self:_progression())end;function a5:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do if l%2==0 and s%2==0 and l<self.height and s<self.width then table.insert(k,q.new(l,s,a0.CELL_STATES.UNVISITED,0))else table.insert(k,q.new(l,s,a0.CELL_STATES.WALL,0))end end end;coroutine.yield({self:_updateFromWall(self._walls:peek(),a0.CELL_STATES.SELECTED)})coroutine.yield(k)local aa={i=0,j=0}while self._count>0 do local a6=self._walls:pop()local ab,ac=self:_getSets(a6)if ab:connected(ac)then local k={self:_updateFromWall(a6,a0.CELL_STATES.WALL)}if not self._walls:isEmpty()then table.insert(k,self:_updateFromWall(self._walls:peek(),a0.CELL_STATES.SELECTED))end;coroutine.yield(k)else self._count=self._count-1;local k={self:_updateFromWall(a6,a0.CELL_STATES.VISITED),self:_updateFromSet(ab,a0.CELL_STATES.VISITED),self:_updateFromSet(ac,a0.CELL_STATES.VISITED)}if not self._walls:isEmpty()then table.insert(k,self:_updateFromWall(self._walls:peek(),a0.CELL_STATES.SELECTED))end;coroutine.yield(k)ab:union(ac)end end;if not self._walls:isEmpty()then coroutine.yield({self:_updateFromWall(self._walls:peek(),a0.CELL_STATES.WALL)})end end;function a0.new(n,o)return a5:new(n,o)end;return a0 end;a['ccmaze.generators.originShift']=function(...)local ad={CELL_STATES={VISITED=1,WALL=2,SELECTED=3}}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local ae={parent={},coords={i=0,j=0}}function ae.new(l,s)return{parent=nil,coords={i=l,j=s}}end;local af={_internalWidth=0,_internalHeight=0,_nodes={},_count=0,_nbSteps=0,_root={}}function af:_progression()return 1.0-self._count/self._nbSteps end;function af:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._nbSteps;for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self._nodes[(l-1)*self._internalWidth+s]=ae.new(l,s)end end;for l=1,self._internalHeight,1 do for s=1,self._internalWidth-1,1 do self._nodes[(l-1)*self._internalWidth+s].parent=self._nodes[(l-1)*self._internalWidth+s+1]end;if l<self._internalHeight then self._nodes[l*self._internalWidth].parent=self._nodes[(l+1)*self._internalWidth]end end;self._root=self:_getNode({i=self._internalHeight,j=self._internalWidth})end;function af:new(n,o,ag)local O=M.new(n,o)af.__index=af;setmetatable(af,{__index=getmetatable(O)})setmetatable(O,af)O._nbSteps=ag;return O end;function af:_updateWall(S,T,t)return q.new(S.i+T.i,S.j+T.j,t,self:_progression())end;function af:_updateCell(U,t)return q.new(U.i*2,U.j*2,t,self:_progression())end;function af:_getNode(U)return self._nodes[(U.i-1)*self._internalWidth+U.j]end;function af:_getRandomNeighbor(U)local V={i=U.i-1,j=U.j}local W={i=U.i+1,j=U.j}local X={i=U.i,j=U.j-1}local Y={i=U.i,j=U.j+1}local Z={}if U.i>1 then table.insert(Z,V)end;if U.i<self._internalHeight then table.insert(Z,W)end;if U.j>1 then table.insert(Z,X)end;if U.j<self._internalWidth then table.insert(Z,Y)end;return Z[math.random(#Z)]end;function af:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do local ah=l%2==0 and s>1 and s<self.width and l<self.height;local ai=l>1 and l<self.height and s==self.width-1;if ah or ai then table.insert(k,q.new(l,s,ad.CELL_STATES.VISITED,0))else table.insert(k,q.new(l,s,ad.CELL_STATES.WALL,0))end end end;table.insert(k,self:_updateCell(self._root.coords,ad.CELL_STATES.SELECTED))coroutine.yield(k)while self._count>0 do local aj=self:_getRandomNeighbor(self._root.coords)local ak=self:_getNode(aj)coroutine.yield({self:_updateWall(aj,ak.parent.coords,ad.CELL_STATES.WALL),self:_updateWall(self._root.coords,aj,ad.CELL_STATES.VISITED),self:_updateCell(self._root.coords,ad.CELL_STATES.VISITED),self:_updateCell(aj,ad.CELL_STATES.SELECTED)})ak.parent=nil;self._root.parent=ak;self._root=ak;self._count=self._count-1 end;coroutine.yield({self:_updateCell(self._root.coords,ad.CELL_STATES.VISITED)})end;function ad.new(n,o,ag)return af:new(n,o,ag)end;return ad end;a['ccmaze.postprocess.builder']=function(...)local w={}local f=require("ccmaze.utils.optFunc")function w.build(x,y,i)return function(k)f.create1(i)(x(k,unpack(y)))end end;return w end;a['ccmaze.postprocess.computerCraft']=function(...)local z={}local w=require("ccmaze.postprocess.builder")local function al(k,am)sleep(am)return k end;local function A(k,B,an)for l=1,#k,1 do local m=k[l]B.setBackgroundColor(an[m.state])B.setCursorPos(m.j,m.i)B.write(" ")end;return k end;function z.wait(am,i)return w.build(al,{am},i)end;function z.updateScreen(B,an,i)return w.build(A,{B,an},i)end;return z end;a['ccmaze.utils.dSet']=function(...)local a1={}local ao={data=nil,_parent={},_rang=0}function ao:new(ap)ap=ap or{data=nil,_parent=nil,_rang=0}ap._parent=ap;setmetatable(ap,self)self.__index=self;return ap end;function ao:union(aq)local ar=self:find()local as=aq:find()if ar~=as then if ar._rang<aq._rang then ar._parent=as else as._parent=ar;if ar._rang==as._rang then ar._rang=ar._rang+1 end end end end;function ao:find()if self._parent~=self then self._parent=self._parent:find()end;return self._parent end;function ao:connected(aq)return self:find()==aq:find()end;function a1.new()return ao:new()end;function a1.makeSet(at)return ao:new{data=at,_parent=nil,_rang=0}end;return a1 end;a['ccmaze.utils.optFunc']=function(...)local f={}function f.create1(x)return x or function(au)end end;return f end;a['ccmaze.utils.shuffle']=function(...)local av={}local function aw(ax)for l=#ax,2,-1 do local s=math.random(l)ax[l],ax[s]=ax[s],ax[l]end end;function av.inPlace(ax)aw(ax)end;return av end;a['ccmaze.utils.stack']=function(...)local Q={}local av=require"ccmaze.utils.shuffle"local ay={_data={}}function ay:new(ap)ap=ap or{_data={}}setmetatable(ap,self)self.__index=self;return ap end;function ay:isEmpty()return#self._data==0 end;function ay:size()return#self._data end;function ay:push(az)table.insert(self._data,az)end;function ay:pop()return table.remove(self._data)end;function ay:popOr(aA)if#self._data>0 then return table.remove(self._data)else return aA end end;function ay:peek()return self._data[#self._data]end;function ay:peekOr(aA)if#self._data>0 then return self._data[#self._data]else return aA end end;function ay:shuffle()av.inPlace(self._data)end;function Q.new()return ay:new()end;function Q.makeStack(ax)return ay:new{_data=ax}end;return Q end;return d
