local a={}local b=require;local require=function(c)return a[c]()or b(c)end;local d={require=require}a['ccmaze.maze']=function(...)local e={}local f=require("ccmaze.utils.optFunc")local g={width=0,height=0,cells={}}function g:update_grid(h,i)repeat local j,k=coroutine.resume(h)if k~=nil and j then for l=1,#k,1 do local m=k[l]self.cells[(m.i-1)*self.width+m.j]=m.state end;f.create1(i)(k)end until not j end;function g:new(n,o,h,i)local p={width=n,height=o,cells={}}setmetatable(p,self)self.__index=self;for l=1,n*o,1 do p.cells[l]=0 end;p:update_grid(h,f.create1(i))return p end;function e.new(n,o,h,i)return g:new(n,o,h,f.create1(i))end;return e end;a['ccmaze.stateUpdate']=function(...)local q={}local r={i=0,j=0,state=0,progress=0}function r:new(l,s,t,u)local v={i=l,j=s,state=t,progress=u}setmetatable(v,self)self.__index=self;return v end;function q.new(l,s,t,u)return r:new(l,s,t,u)end;return q end;a['ccmaze.filters.builder']=function(...)local w={}function w.build(h,x,y)return coroutine.create(function()repeat local j,k=coroutine.resume(h)if k~=nil and j then k=x(k,unpack(y or{}))coroutine.yield(k)end until not j end)end;return w end;a['ccmaze.filters.computerCraft']=function(...)local z={}local w=require("ccmaze.filters.builder")local function A(k,B,C)for l=1,#k,1 do local m=k[l]B.setBackgroundColor(C(m.state))B.setCursorPos(m.j,m.i)B.write(" ")end;return k end;local function D(B,E,F,G,H)B.setBackgroundColor(colors.black)B.setTextColor(colors.white)B.setCursorPos(E,F)B.write(string.rep(" ",H))B.setCursorPos(E,F)B.write(G)end;local function I(k,B,E,F,J,K)local L=0;for l=1,#k,1 do local m=k[l]L=math.max(L,m.progress)end;local G=J..string.format("%.2f",L*100).."%"D(B,E,F,G,K+7)return k end;function z.updateScreen(h,B,C)return w.build(h,A,{B,C})end;function z.displayProgress(h,B,E,F,J,K)return w.build(h,I,{B,E,F,J,K})end;return z end;a['ccmaze.generators.abstract']=function(...)local M={}local N={width=0,height=0,cellStates={}}function N:new(n,o)N.__index=N;local O={width=n,height=o,cellStates={}}setmetatable(O,N)return O end;function N:producer()return coroutine.create(function()self:_init()self:generate()end)end;function N:generate()error("Abstract method Generator:generate called",1)end;function N:_init()error("Abstract method Generator:_init called",1)end;function N:_progression()error("Abstract method Generator:_progression called",1)end;function M.new(n,o)return N:new(n,o)end;return M end;a['ccmaze.generators.deepFirst']=function(...)local P={}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local Q=require("ccmaze.utils.stack")local R={VISITED=1,WALL=2,UNVISITED=3,SELECTED=4}local S={_internalWidth=0,_internalHeight=0,_cells={},_path={},_count=0,_startCoords={},cellStates=R}function S:_progression()return 1.0-self._count/(self._internalWidth*self._internalHeight-1)end;function S:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._internalWidth*self._internalHeight-1;self._path=Q.new()for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self:_setState({i=l,j=s},R.UNVISITED)end end;self._startCoords={i=math.random(self._internalHeight),j=math.random(self._internalWidth)}self:_setState(self._startCoords,R.VISITED)self._path:push(self._startCoords)end;function S:new(n,o)local O=M.new(n,o)S.__index=S;setmetatable(S,{__index=getmetatable(O)})setmetatable(O,S)O.cellStates=R;return O end;function S:_updateWall(T,U,t)return q.new(T.i+U.i,T.j+U.j,t,self:_progression())end;function S:_updateCell(V,t)return q.new(V.i*2,V.j*2,t,self:_progression())end;function S:_getState(V)return self._cells[(V.i-1)*self._internalWidth+V.j]end;function S:_setState(V,t)self._cells[(V.i-1)*self._internalWidth+V.j]=t end;function S:_isUnvisited(V)return self:_getState(V)==R.UNVISITED end;function S:_getRandomNeighbor(V)local W={i=V.i-1,j=V.j}local X={i=V.i+1,j=V.j}local Y={i=V.i,j=V.j-1}local Z={i=V.i,j=V.j+1}local _={}if V.i>1 and self:_isUnvisited(W)then table.insert(_,W)end;if V.i<self._internalHeight and self:_isUnvisited(X)then table.insert(_,X)end;if V.j>1 and self:_isUnvisited(Y)then table.insert(_,Y)end;if V.j<self._internalWidth and self:_isUnvisited(Z)then table.insert(_,Z)end;if#_==0 then return nil else return _[math.random(#_)]end end;function S:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do if l%2==0 and s%2==0 and l<self.height and s<self.width then table.insert(k,q.new(l,s,R.UNVISITED,0))else table.insert(k,q.new(l,s,R.WALL,0))end end end;table.insert(k,self:_updateCell(self._path:peek(),R.SELECTED))coroutine.yield(k)while self._count>0 do local V=self._path:pop()if self:_isUnvisited(V)then self._count=self._count-1;self:_setState(V,R.VISITED)end;local a0=self:_getRandomNeighbor(V)if a0~=nil then self._path:push(V)self._path:push(a0)coroutine.yield({self:_updateWall(V,a0,R.VISITED),self:_updateCell(V,R.VISITED),self:_updateCell(a0,R.SELECTED)})else coroutine.yield({self:_updateCell(V,R.VISITED),self:_updateCell(self._path:peekOr(self._startCoords),R.SELECTED)})end end;coroutine.yield({self:_updateCell(self._path:popOr(self._startCoords),R.VISITED)})end;function P.new(n,o)return S:new(n,o)end;return P end;a['ccmaze.generators.kruskal']=function(...)local a1={}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local a2=require("ccmaze.utils.dSet")local Q=require("ccmaze.utils.stack")local a3={VERTICAL=0,HORIZONTAL=1}local a4={i=0,j=0,direction=a3.VERTICAL}function a4.new(l,s,a5)return{i=l,j=s,direction=a5}end;local R={VISITED=1,WALL=2,UNVISITED=3,SELECTED=4}local a6={_internalWidth=0,_internalHeight=0,_sets={},_walls={},_count=0,cellStates=R}function a6:_progression()return 1.0-self._count/(self._internalWidth*self._internalHeight-1)end;function a6:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._internalWidth*self._internalHeight-1;self._walls=Q.new()self._sets={}for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self._sets[(l-1)*self._internalWidth+s]=a2.makeSet({i=l,j=s})if l>1 then self._walls:push(a4.new(l,s,a3.VERTICAL))end;if s>1 then self._walls:push(a4.new(l,s,a3.HORIZONTAL))end end end;self._walls:shuffle()end;function a6:new(n,o)local O=M.new(n,o)a6.__index=a6;setmetatable(a6,{__index=getmetatable(O)})setmetatable(O,a6)O.cellStates=R;return O end;function a6:_getSets(a7)if a7.direction==a3.VERTICAL then return self._sets[(a7.i-2)*self._internalWidth+a7.j],self._sets[(a7.i-1)*self._internalWidth+a7.j]else return self._sets[(a7.i-1)*self._internalWidth+a7.j-1],self._sets[(a7.i-1)*self._internalWidth+a7.j]end end;function a6:_updateFromWall(a7,t)local a8=a7.i*2;local a9=a7.j*2;if a7.direction==a3.VERTICAL then a8=a8-1 end;if a7.direction==a3.HORIZONTAL then a9=a9-1 end;return q.new(a8,a9,t,self:_progression())end;function a6:_updateFromSet(aa,t)local a8=aa.data.i*2;local a9=aa.data.j*2;return q.new(a8,a9,t,self:_progression())end;function a6:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do if l%2==0 and s%2==0 and l<self.height and s<self.width then table.insert(k,q.new(l,s,R.UNVISITED,0))else table.insert(k,q.new(l,s,R.WALL,0))end end end;coroutine.yield({self:_updateFromWall(self._walls:peek(),R.SELECTED)})coroutine.yield(k)local ab={i=0,j=0}while self._count>0 do local a7=self._walls:pop()local ac,ad=self:_getSets(a7)if ac:connected(ad)then local k={self:_updateFromWall(a7,R.WALL)}if not self._walls:isEmpty()then table.insert(k,self:_updateFromWall(self._walls:peek(),R.SELECTED))end;coroutine.yield(k)else self._count=self._count-1;local k={self:_updateFromWall(a7,R.VISITED),self:_updateFromSet(ac,R.VISITED),self:_updateFromSet(ad,R.VISITED)}if not self._walls:isEmpty()then table.insert(k,self:_updateFromWall(self._walls:peek(),R.SELECTED))end;coroutine.yield(k)ac:union(ad)end end;if not self._walls:isEmpty()then coroutine.yield({self:_updateFromWall(self._walls:peek(),R.WALL)})end end;function a1.new(n,o)return a6:new(n,o)end;return a1 end;a['ccmaze.generators.originShift']=function(...)local ae={}local q=require("ccmaze.stateUpdate")local M=require("ccmaze.generators.abstract")local af={parent={},coords={i=0,j=0}}function af.new(l,s)return{parent=nil,coords={i=l,j=s}}end;local R={VISITED=1,WALL=2,SELECTED=3}local ag={_internalWidth=0,_internalHeight=0,_nodes={},_count=0,_nbSteps=0,_root={},cellStates=R}function ag:_progression()return 1.0-self._count/self._nbSteps end;function ag:_init()self._internalWidth=math.floor((self.width-1)/2)self._internalHeight=math.floor((self.height-1)/2)self._count=self._nbSteps;for l=1,self._internalHeight,1 do for s=1,self._internalWidth,1 do self._nodes[(l-1)*self._internalWidth+s]=af.new(l,s)end end;for l=1,self._internalHeight,1 do for s=1,self._internalWidth-1,1 do self._nodes[(l-1)*self._internalWidth+s].parent=self._nodes[(l-1)*self._internalWidth+s+1]end;if l<self._internalHeight then self._nodes[l*self._internalWidth].parent=self._nodes[(l+1)*self._internalWidth]end end;self._root=self:_getNode({i=self._internalHeight,j=self._internalWidth})end;function ag:new(n,o,ah)local O=M.new(n,o)ag.__index=ag;setmetatable(ag,{__index=getmetatable(O)})setmetatable(O,ag)O.cellStates=R;O._nbSteps=ah;return O end;function ag:_updateWall(T,U,t)return q.new(T.i+U.i,T.j+U.j,t,self:_progression())end;function ag:_updateCell(V,t)return q.new(V.i*2,V.j*2,t,self:_progression())end;function ag:_getNode(V)return self._nodes[(V.i-1)*self._internalWidth+V.j]end;function ag:_getRandomNeighbor(V)local W={i=V.i-1,j=V.j}local X={i=V.i+1,j=V.j}local Y={i=V.i,j=V.j-1}local Z={i=V.i,j=V.j+1}local _={}if V.i>1 then table.insert(_,W)end;if V.i<self._internalHeight then table.insert(_,X)end;if V.j>1 then table.insert(_,Y)end;if V.j<self._internalWidth then table.insert(_,Z)end;return _[math.random(#_)]end;function ag:generate()local k={}for l=1,self.height,1 do for s=1,self.width,1 do local ai=l%2==0 and s>1 and s<self.width and l<self.height;local aj=l>1 and l<self.height and s==self.width-1;if ai or aj then table.insert(k,q.new(l,s,R.VISITED,0))else table.insert(k,q.new(l,s,R.WALL,0))end end end;table.insert(k,self:_updateCell(self._root.coords,R.SELECTED))coroutine.yield(k)while self._count>0 do local ak=self:_getRandomNeighbor(self._root.coords)local al=self:_getNode(ak)coroutine.yield({self:_updateWall(ak,al.parent.coords,R.WALL),self:_updateWall(self._root.coords,ak,R.VISITED),self:_updateCell(self._root.coords,R.VISITED),self:_updateCell(ak,R.SELECTED)})al.parent=nil;self._root.parent=al;self._root=al;self._count=self._count-1 end;coroutine.yield({self:_updateCell(self._root.coords,R.VISITED)})end;function ae.new(n,o,ah)return ag:new(n,o,ah)end;return ae end;a['ccmaze.postprocess.builder']=function(...)local w={}local f=require("ccmaze.utils.optFunc")function w.build(x,y,i)return function(k)f.create1(i)(x(k,unpack(y)))end end;return w end;a['ccmaze.postprocess.computerCraft']=function(...)local z={}local w=require("ccmaze.postprocess.builder")local function am(k,an)sleep(an)return k end;local function A(k,B,ao)for l=1,#k,1 do local m=k[l]B.setBackgroundColor(ao[m.state])B.setCursorPos(m.j,m.i)B.write(" ")end;return k end;function z.wait(an,i)return w.build(am,{an},i)end;function z.updateScreen(B,ao,i)return w.build(A,{B,ao},i)end;return z end;a['ccmaze.utils.dSet']=function(...)local a2={}local ap={data=nil,_parent={},_rang=0}function ap:new(aq)aq=aq or{data=nil,_parent=nil,_rang=0}aq._parent=aq;setmetatable(aq,self)self.__index=self;return aq end;function ap:makeSet(ar)return ap:new{data=ar,_parent=nil,_rang=0}end;function ap:union(as)local at=self:find()local au=as:find()if at~=au then if at._rang<as._rang then at._parent=au else au._parent=at;if at._rang==au._rang then at._rang=at._rang+1 end end end end;function ap:find()if self._parent~=self then self._parent=self._parent:find()end;return self._parent end;function ap:connected(as)return self:find()==as:find()end;function a2.new()return ap:new()end;function a2.makeSet(ar)return ap:makeSet(ar)end;return a2 end;a['ccmaze.utils.optFunc']=function(...)local f={}function f.create1(x)return x or function(av)end end;return f end;a['ccmaze.utils.shuffle']=function(...)local aw={}local function ax(ay)for l=#ay,2,-1 do local s=math.random(l)ay[l],ay[s]=ay[s],ay[l]end end;function aw.inPlace(ay)ax(ay)end;return aw end;a['ccmaze.utils.stack']=function(...)local Q={}local aw=require"ccmaze.utils.shuffle"local az={_data={}}function az:new(aq)aq=aq or{_data={}}setmetatable(aq,self)self.__index=self;return aq end;function az:makeStack(ay)return az:new{_data=ay}end;function az:isEmpty()return#self._data==0 end;function az:size()return#self._data end;function az:push(aA)table.insert(self._data,aA)end;function az:pop()return table.remove(self._data)end;function az:popOr(aB)if#self._data>0 then return table.remove(self._data)else return aB end end;function az:peek()return self._data[#self._data]end;function az:peekOr(aB)if#self._data>0 then return self._data[#self._data]else return aB end end;function az:shuffle()aw.inPlace(self._data)end;function Q.new()return az:new()end;function Q.makeStack(ay)return az:makeStack(ay)end;return Q end;return d
